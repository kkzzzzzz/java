package ProducerAndConsumerModel;import java.util.LinkedList;import java.util.Queue;import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created with IntelliJ IDEA. * Project: test-jar * Author: Kevin * Date: 2019/3/5 * Time: 7:39 PM * 并发瓶颈很明显，因为在锁 BUFFER_LOCK 看来， 任何消费者线程与生产者线程都是一样的。 换句话说，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）操作缓冲区 buffer。 而实际上，如果缓冲区是一个队列的话， “生产者将产品入队”与“消费者将产品出队”两个操作之间没有同步关系， 可以在队首出队的同时，在队尾入队。理想性能可提升至实现三的两倍。 */public class LockConditionModel implements Model{	private final Lock BUFFER_LOCK = new ReentrantLock();	private final Condition BUFFER_COND = BUFFER_LOCK.newCondition();	private final Queue<Task> buffer = new LinkedList<>();	private final int cap;	private final AtomicInteger increTaskNo = new AtomicInteger(0);	public LockConditionModel(int cap) {		this.cap = cap;	}	@Override	public Runnable newRunnableConsumer() {		return new ConsumerImpl();	}	@Override	public Runnable newRunnableProducer() {		return new ProducerImpl();	}	private class ConsumerImpl extends AbstractConsumer{		@Override		public void consume() throws InterruptedException {			BUFFER_LOCK.lockInterruptibly();			try {				while (buffer.size() == 0) {					BUFFER_COND.await();				}				Task task = buffer.poll();				assert task != null;				// 固定时间范围的消费，模拟相对稳定的服务器处理过程				Thread.sleep(500 + (long) (Math.random() * 500));				System.out.println("consume: " + task.no);				BUFFER_COND.signalAll();			} finally {				BUFFER_LOCK.unlock();			}		}	}	private class ProducerImpl extends AbstarchProducer{		@Override		public void produce() throws InterruptedException {			// 不定期生产，模拟随机的用户请求			Thread.sleep((long) (Math.random() * 1000));			BUFFER_LOCK.lockInterruptibly();			try {				while (buffer.size() == cap) {					BUFFER_COND.await();				}				Task task = new Task(increTaskNo.getAndIncrement());				buffer.offer(task);				System.out.println("produce: " + task.no);				BUFFER_COND.signalAll();			} finally {				BUFFER_LOCK.unlock();			}		}	}	public static void main(String[] args) {		Model model = new WaitNotifyModel(3);		for (int i = 0; i < 2; i++) {			new Thread(model.newRunnableConsumer()).start();		}		for (int i = 0; i < 5; i++) {			new Thread(model.newRunnableProducer()).start();		}	}}